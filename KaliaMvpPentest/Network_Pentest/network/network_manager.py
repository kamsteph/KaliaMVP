# new_module/network_manager_async.py
import logging
from typing import Dict, Any, List
import asyncio

from G_L_L.l_region.local_learner import LocalLearner
from back_end.GraphNN import GNNBrain
from Network_Pentest.network.Sub_Unit_Manager_Network.network_exploitation_manager import ExploitationManagerAI
from back_end.utils.colored_logger import get_logger
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus


logger = get_logger(__name__, component="MANAGER", region="NETWORK")
logger.setLevel(logging.INFO)


class NetworkManager:
    """
    Fully async high-level AI Agent for Network Pentesting.
    Orchestrates Recon, VulnScan, and Exploitation.
    Integrates Local Learner for exploitation feedback.
    """

    def __init__(self, bus: EventBus, local_learner: LocalLearner, db: DatabaseManager, gnn_model_path: str = None):
        self.bus = bus
        self.db = db
        self.local_learner = local_learner

        # Load GNN brain for post-recon decision making
        self.gnn_brain = GNNBrain(model_path=gnn_model_path)

        # Async exploitation manager
        self.exploit_mgr = ExploitationManagerAI(db, bus)

        logger.info("[NETWORK][MANAGER] Initialized as an async AI Agent")

        # Subscribe to network region tasks using async wrapper
        self.bus.subscribe("network", self._async_task_wrapper)

    def _async_task_wrapper(self, task: Dict[str, Any]):
        """Wrap async handle_task for EventBus subscriptions that are sync."""
        asyncio.create_task(self.handle_task(task))

    async def handle_task(self, task: Dict[str, Any]):
        """Main async handler for network tasks."""
        logger.info(f"[NETWORK][MANAGER] Received task: {task}")
        action = task.get("action", "initial_scan")
        targets = task.get("target", [])

        if not targets:
            logger.warning("[NetworkManager] No targets specified. Skipping task.")
            return

        if action == "initial_scan":
            # Delegate to ReconManager via event bus
            self.bus.publish_task({
                "region": "network",
                "action": "network_recon_scan",
                "targets": targets
            })

        elif action == "post_recon_decision":
            recon_results = task.get("scan_results", {})
            if not recon_results:
                logger.warning("[NetworkManager] No recon results provided. Skipping.")
                return

            # Save to DB
            self.db.save_scan_result(recon_results)

            # Decide next action using GNN
            next_action = self.gnn_brain.predict([recon_results])

            if next_action == "exploitation":
                self.bus.publish_task({
                    "region": "network",
                    "action": "run_exploitation",
                    "target": targets
                })
            elif next_action == "deeper_scan":
                self.bus.publish_task({
                    "region": "network",
                    "action": "run_deeper_scan",
                    "target": targets
                })

        elif action == "run_exploitation":
            # Await async exploitation and feed results to local learner
            exploit_results = await self._run_exploitation(targets)

            # Save results to DB
            self.db.save_scan_result(exploit_results)

            # Push only new/unrecognized events to global learning
            if "new_for_global" in exploit_results:
                self.bus.publish_task({
                    "region": "learning",
                    "source_region": "network",
                    "results_ids": [str(r.get('_id', 'unknown')) for r in exploit_results["new_for_global"]]
                })

    async def _run_exploitation(self, targets: List[str]) -> Dict[str, Any]:
        """Async delegation to ExploitationManager + local learner."""
        all_results = {}

        for target in targets:
            exploit_res = await self.exploit_mgr.handle_scan_result({"target": [target]})
            all_results[target] = exploit_res

        # Feed results to local learner (sync)
        new_for_global = self.local_learner.local_knowledge([
            {
                "target": t,
                "vulnerabilities": r,
                "status": "success"  # adapt fields to your model
            } for t, r in all_results.items()
        ])

        return {"targets": targets, "exploit_results": all_results, "new_for_global": new_for_global}