import logging
import uuid
from datetime import datetime
from typing import Dict, Any, List, Optional

from G_L_L.l_region.Aggregation_area import correlator
from Web_Pentest.web.web_osint import gather_main_osint_info
from back_end.utils.colored_logger import get_logger
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus
from back_end.utils.export_report import export_report
from back_end.mini_transformer.attack_surface_translator import AttackSurfaceTranslator
from back_end.mini_transformer.attack_surfaces import ATTACK_SURFACE_MAP
from back_end.pentest_research import PentestResearchRAG
from data_augmentation import DataAugmentor
#from Web_Pentest.web.web_osint import gather_main_osint_info

logger = get_logger(__name__, component="ORCHESTRATOR", region="CONTROLLER")
logger.setLevel(logging.DEBUG)

translator = AttackSurfaceTranslator()
class PentestOrchestrator:
    def __init__(self, bus: EventBus, db: DatabaseManager):
        self.bus = bus
        self.db = db
        self.regions = ["network", "web"]
        self.rag = PentestResearchRAG()  # <-- init RAG
        self.completed_tasks = []
        logger.info("PentestOrchestrator initialized with regions: %s", self.regions)

    async def submit_scan_request(
            self,
            region: str,
            scan_type: str,
            scope: str,
            target: List[str],
            tools: Optional[Dict[str, Any]] = None,
            cross_domain_insight: bool = False,
            **kwargs
    ) -> Dict[str, Any]:

        if region not in self.regions:
            raise ValueError(f"Unknown region: {region}")
        if not target:
            raise ValueError("submit_scan_request requires at least one target")

        # --- Extract flexible parameters ---
        attack_surface: List[str] = kwargs.get("attack_surface", ["full"])
        insider_docs: Optional[List[str]] = kwargs.get("insider_docs")
        codebase_docs: Optional[List[str]] = kwargs.get("codebase_docs")
        social_media_url: Optional[str] = kwargs.get("social_media_url")

        hints: Dict[str, Any] = {}

        # --- Scope handling ---
        if scope == "white":
            if not codebase_docs:
                raise ValueError("White-box scope requires codebase documents")
            hints["codebase_docs"] = codebase_docs
            hints["scope"] = "white"
            research_notes = self.rag.research(
                f"Full internal {region} pentest analysis for targets {target}. Analyze codebase & configs."
            ) if self.rag else {"note": "White-box codebase provided, RAG inactive."}

        elif scope == "grey":
            if not insider_docs:
                raise ValueError("Grey-box scope requires at least one insider document")
            hints["insider_docs"] = insider_docs
            hints["scope"] = "grey"
            research_notes = self.rag.research(
                f"Partial insider {region} pentest for targets {target}. Analyze insider docs."
            ) if self.rag else {"note": "Grey-box mode, no RAG active."}

        else:  # black-box
            hints["scope"] = "black"
            research_notes = {"note": "Black-box minimal reconnaissance."}

        # --- Attack surface ---
        resolved_surface = []
        for surf in attack_surface:
            try:
                definition = self.resolve_attack_surface(surf)
                enrichment = self.rag.research(
                    f"Explain risks, common misconfigurations, and known CVEs for {surf} in a pentest context."
                ) if self.rag else {"note": f"No RAG available for {surf}, fallback to DB lookup."}
                resolved_surface.append({
                    "surface": surf,
                    "definition": definition,
                    "enrichment": enrichment
                })
            except ValueError:
                logger.warning(f"Unknown attack surface: {surf}")
        hints["attack_surface"] = resolved_surface

        # --- Web-specific OSINT ---
        if region == "web" and social_media_url:
            osint_data = gather_main_osint_info(social_media_url)
            if self.rag:
                enriched_osint = self.rag.research(
                    f"Analyze OSINT data for {social_media_url}. Identify social engineering risks, leaks, or exposures."
                )
            else:
                enriched_osint = {"note": "No RAG available, raw OSINT only."}
            hints["social_osint"] = {"raw": osint_data, "enriched": enriched_osint}

        # --- Tools ---
        vuln_tools = []
        exploit_tool = "Default"
        if tools:
            if not isinstance(tools, dict):
                raise ValueError("tools must be a dictionary")
            vuln_tools = tools.get("vuln_tools", [])
            if isinstance(vuln_tools, str):
                vuln_tools = [vuln_tools]
            exploit_tool = tools.get("exploit_tool", "Default")
        hints["tools"] = {"vuln_tools": vuln_tools, "exploit_tool": exploit_tool}

        # --- Cross-domain insights ---
        cross_domain_info = {}
        if cross_domain_insight:
            events = list(self.db.learning_data.find({}))
            cross_domain_info = correlator.compute_cross_domain_potential(events)

        # --- Task creation ---
        task_id = str(uuid.uuid4())
        task = {
            "id": task_id,
            "region": region,
            "action": f"initial_{region}_scan",
            "target": target,
            "scan_type": scan_type,
            "scope": scope,
            "research": research_notes,
            "hints": hints,
            "cross_domain_info": cross_domain_info
        }

        self.db.results.insert_one({
            "_id": task_id,
            "task_id": task_id,
            "task": task,
            "status": "queued",
            "created_at": datetime.now()
        })

        logger.info("Submitting scan request to EventBus: %s", task)
        self.bus.publish_task(task)
        self.bus.subscribe("task_completed", self.handle_completed_task)

        response = {
            "status": "accepted",
            "task_id": task_id,
            "region": region,
            "scope": scope,
            "research": research_notes,
            "message": "Scan request published. Awaiting completion."
        }
        response.update(cross_domain_info)
        return response

    def handle_completed_task(self, task_result: Dict[str, Any]):
        """
        Callback triggered when a manager signals a task is complete.
        """
        self.completed_tasks.append(task_result)
        logger.info(f"Received completion signal for task in region '{task_result.get('region')}'.")

    async def generate_final_report(self, task_name: str, export_format: str = "both"):
        """
        Retrieves all data from the database and generates a final report.
        """
        logger.info("Generating final report...")

        # Run full batch augmentation
        logger.info("enriching the augmented_db")
        augmentor = DataAugmentor(self.db)
        augmentor.run()

        # 1. Retrieve all scan results from the database
        all_results_cursor = self.db.results.find({})
        all_results = list(all_results_cursor)

        if not all_results:
            logger.warning("No scan results found in the database to generate a report.")
            return

        # 2. Consolidate data into a summary text
        summary_lines = [
            f"# Comprehensive Pentest Report - {task_name}",
            f"**Generated on:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "\n## Consolidated Findings:",
        ]

        for result in all_results:
            result_type = result.get("type", "unknown")
            if result_type == "initial_web_scan" and result.get("vulnerabilities"):
                for vuln in result.get("vulnerabilities"):
                    summary_lines.append(f"- **{vuln.get('alert', 'N/A')}** (Risk: {vuln.get('risk')}, URL: {vuln.get('url')})")
            elif result_type == "web_exploitation":
                summary_lines.append("\n### Web Exploitation Results:")
                for vuln, outcome in result.get("exploit_results", {}).items():
                    summary_lines.append(f"- **Exploit for {vuln}**: {outcome}")

        summary_text = "\n".join(summary_lines)

        # 3. Use the export_report functions to create the final documents
        directory = "reports"
        filename = f"{task_name}_final_report"

        saved_files = export_report(summary_text, directory, filename, export_format)

        if saved_files:
            logger.info(f"Final report successfully saved to: {saved_files}")
        else:
            logger.error("Failed to save final report.")

    async def submit_cross_domain_validation(self, task_id: str) -> Dict[str, Any]:
            """
            Called only when user explicitly validates cross-domain attack.
            """
            task = next((t for t in self.completed_tasks if t["id"] == task_id), None)
            if not task:
                raise ValueError(f"No completed task found with id {task_id}")

            logger.info("[Orchestrator] User requested cross-domain validation for task %s", task_id)

            # Pass task to validator/global learner pipeline
            validation_task = {
                "id": str(uuid.uuid4()),
                "region": "cross_domain",
                "action": "validate_cross_domain",
                "related_task": task_id,
                "input": task,
            }

            self.bus.publish_task(validation_task)

            return {
                "status": "queued",
                "validation_task_id": validation_task["id"],
                "message": "Cross-domain validation has been queued."
            }

    def resolve_attack_surface(user_value: str):
        if user_value in ATTACK_SURFACE_MAP:
            return ATTACK_SURFACE_MAP[user_value]

        # Fallback to semantic translation
        mapped, score = translator.translate(user_value)
        if mapped:
            return ATTACK_SURFACE_MAP[mapped]

        raise ValueError(f"Unknown attack surface: {user_value}")