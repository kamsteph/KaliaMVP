# backend/main.py
import os
from contextlib import asynccontextmanager
from typing import List, Dict, Any, Optional

from dotenv import load_dotenv
from fastapi import FastAPI, UploadFile, File, Form
from starlette.middleware.cors import CORSMiddleware

from G_L_L.l_region.local_learner import LocalLearner
from back_end.bootstrap_network_cap import bootstrap_network_capability_matrix
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus
from back_end.pentest_orchestrator import PentestOrchestrator, translator
from Network_Pentest.network.network_manager import NetworkManager
from back_end.websocket_bridge import WebSocketBridge

# --- Load environment ---
load_dotenv()
msf_rpc_config = {
    "host": os.getenv("MSF_HOST"),
    "port": int(os.getenv("MSF_PORT")),
    "password": os.getenv("MSF_PASSWORD")
}

# --- Bootstrap network capability matrix into MongoDB ---
bootstrap_network_capability_matrix()

# --- FastAPI app and lifespan ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    await ws_bridge.start()
    yield
    await ws_bridge.stop()

app = FastAPI(lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # restrict in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Initialize core components ---
db_manager = DatabaseManager()
event_bus = EventBus()
l_network = LocalLearner(region="network", bus=event_bus)
network_manager = NetworkManager(event_bus, db=db_manager, local_learner=l_network)
orchestrator = PentestOrchestrator(bus=event_bus, db=db_manager)
ws_bridge = WebSocketBridge(event_bus)

# --- Event subscriptions ---
event_bus.subscribe("network", network_manager.handle_task)
event_bus.subscribe("network_exploitation_results", l_network.handle_exploitation_results)


# --- FastAPI endpoints ---

@app.post("/scan")
async def start_scan(
        region: str = Form(...),
        scan_type: str = Form(...),
        scope: str = Form(...),
        target: List[str] = Form(...),
        cross_domain_insight: bool = Form(False),
        name: Optional[str] = Form(None),
        description: Optional[str] = Form(None),
        attack_surface: Optional[List[str]] = Form(["full"]),
        tools: Optional[str] = Form(None),  # JSON string for tools dict
        codebase_files: Optional[List[UploadFile]] = File(None),
        insider_files: Optional[List[UploadFile]] = File(None),
        social_media_url: Optional[str] = Form(None)
):
    """
    Triggers a new pentest scan.
    - codebase_files → white scope
    - insider_files → grey scope
    - social_media_url → only used if region is web
    """

    # Convert tools from JSON string to dict if provided
    import json
    tools_dict = json.loads(tools) if tools else None

    # Save uploaded codebase and insider files locally (or read into memory)
    codebase_paths = []
    insider_paths = []

    if codebase_files:
        for f in codebase_files:
            content = await f.read()
            # store as string, or save to temp file
            path = f"/tmp/codebase_{f.filename}"
            with open(path, "wb") as fp:
                fp.write(content)
            codebase_paths.append(path)

    if insider_files:
        for f in insider_files:
            content = await f.read()
            path = f"/tmp/insider_{f.filename}"
            with open(path, "wb") as fp:
                fp.write(content)
            insider_paths.append(path)

    # Call the orchestrator
    result = await orchestrator.submit_scan_request(
        region=region,
        scan_type=scan_type,
        scope=scope,
        target=target,
        cross_domain_insight=cross_domain_insight,
        name=name,
        description=description,
        attack_surface=attack_surface,
        tools=tools_dict,
        codebase_files=codebase_paths,
        insider_files=insider_paths,
        social_media_url=social_media_url if region == "web" else None
    )

    return result


@app.post("/translate")
async def translate_surface(text: str = Form(...)):
    result = translator.translate(text)
    return {
        "surface": result["surface"],
        "definition": result["definition"],
        "score": result["score"],
    }


@app.get("/scan_results")
async def get_scan_results():
    results = list(db_manager.results.find({}, {"_id": 0}))
    return {"results": results}
