import 'dart:convert';
import 'dart:io';

import 'package:flutter/material.dart';
import '../CustomReusableClass/CustomInputFields.dart';
import '../CustomReusableClass/PentestProgressPage.dart';
import '../CustomReusableClass/ScopeWidget.dart';
import '../DTO/AttackSurface.dart';
import '../DTO/ToolChoice.dart';
import '../DTO/UserStorage.dart';
import '../KaliaPentestingApi/FileUploadApi.dart';
import '../PentestOptions/NetworkPentestAreas.dart';
import 'package:path/path.dart' as path;

class NetworkScanPage extends StatefulWidget {
  final AttackSurface attackSurface;
  const NetworkScanPage({super.key,required this.attackSurface});

  @override
  State<NetworkScanPage> createState() => _NetworkScanPageState();
}

class _NetworkScanPageState extends State<NetworkScanPage> {

  final _formKey = GlobalKey<FormState>();
  late final List<ScopeConfig> _scopeCards = [];

  final TextEditingController _ipRangeController = TextEditingController();
  final TextEditingController _nameTarget = TextEditingController();
  final TextEditingController _descriptionTarget = TextEditingController();

  String _scanMode = "Scan only";
  String _reportFormat = "json";
  final String _scope = "black";
  bool _isScanning = false;
  bool _isCrossDomainInsight = false;
  String _scanMessage = "";

  final Map<String, String> scopeDescriptions = {
    "black": "Black Scope: External only.",
    "grey": "Grey Scope: Adds limited insider info.",
    "white": "White Scope: Full internal access.",
  };

  @override
  void initState() {
    super.initState();

    // _scopeCards.add(ScopeConfig(
    //   selectedAreas: {widget.initialNetworkCategory: widget.initialNetworkAreas},
    // ));
  }

  Widget _buildAddScopeButton() {
    return Center(
      child: OutlinedButton.icon(
        onPressed: _addScopeCard,
        icon: const Icon(Icons.add, color: Colors.blue),
        label: const Text("Add"),
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
          side: const BorderSide(color: Colors.blue),
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
        ),
      ),
    );
  }

  void _addScopeCard() => setState(() => _scopeCards.add(ScopeConfig()));
  void _removeScopeCard(int index) => setState(() => _scopeCards.removeAt(index));

  Future<void> _startScan() async {
    setState(() {
      _isScanning = true;
      _scanMessage = "";
    });

    if (!_formKey.currentState!.validate()) {
      setState(() => _isScanning = false);
      return;
    }

    if (_ipRangeController.text.trim().isEmpty &&
        _scopeCards.every((card) => card.ipControllers.every((c) => c.text.trim().isEmpty))) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Please enter at least one target IP.")),
      );
      setState(() => _isScanning = false);
      return;
    }

    // Save recent inputs
    await UserDataStorage.save("recent_ips", _ipRangeController.text.trim());
    await UserDataStorage.save("recent_targets", _nameTarget.text.trim());

    List<File> codebaseFiles = [];
    List<File> insiderFiles = [];

    for (var card in _scopeCards) {
      codebaseFiles.addAll(card.codebaseFiles.map((pf) => File(pf.path!)));
      insiderFiles.addAll(card.insiderFiles.map((pf) => File(pf.path!)));
    }

    List<File> allFiles = [...codebaseFiles, ...insiderFiles];

    // Upload files if any
    var uploaded = await uploadFiles(allFiles);
    final idByFilename = { for (var e in uploaded) e['original_filename']: e['id'] };

    // Build scopes payload with file IDs (still useful for DB record/body)
    final scopesPayload = _scopeCards.map((s) => {
      "scope": s.scope,
      "target": s.ipControllers.map((c) => c.text.trim()).where((ip) => ip.isNotEmpty).toList(),
      "insider_file_ids": s.insiderFiles.map((pf) => idByFilename[path.basename(pf.path!)]).toList(),
      "codebase_file_ids": s.codebaseFiles.map((pf) => idByFilename[path.basename(pf.path!)]).toList(),
      "vuln_tools": s.vulnTools,
      "exploit_tool": s.exploitTool
    }).toList();

    // Use the multipart sender (postScanMultipart) â€” don't call CombinedPentestAPI.postScan(payload)
    try {
      final result = await postScanMultipart(
        region: "network",
        scanType: _scanMode,
        scope: _scope,
        target: [_ipRangeController.text.trim()].where((ip) => ip.isNotEmpty).toList(),
        reportFormat: _reportFormat,
        crossDomainInsight: _isCrossDomainInsight,
        name: _nameTarget.text.trim(),
        description: _descriptionTarget.text.trim(),
        tools: {"vuln_tools": ["Naabu", "Nmap"], "exploit_tool": "Default"},
        codebaseFiles: codebaseFiles,
        insiderFiles: insiderFiles,
        attackSurface: ["full"],
      );

      final taskId = result["task_id"];
      setState(() {
        _scanMessage = "\nResult:\n${const JsonEncoder.withIndent("  ").convert(result)}\n";
      });

      Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => PentestProgressPage(taskId: taskId)),
      );
    } catch (e) {
      setState(() => _scanMessage = "\nError scanning: $e\n");
    } finally {
      setState(() => _isScanning = false);
    }
  }


  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Network Pentest")),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // const Text("Scope of Definition", style: TextStyle(fontSize: 20,fontWeight: FontWeight.bold)),
              // const SizedBox(height: 8),
              // const SizedBox(width: 20),
              // Column(
              //   crossAxisAlignment: CrossAxisAlignment.start,
              //   children: scopeDescriptions.entries.map((entry) {
              //     return Padding(
              //       padding: const EdgeInsets.only(bottom: 4.0),
              //       child: Text(
              //         entry.value,
              //         style: const TextStyle(fontSize: 13, color: Colors.grey),
              //       ),
              //     );
              //   }).toList(),
              // ),
              // const SizedBox(height: 12),

              for (int i = 0; i < _scopeCards.length; i++)
                ScopeCardWidget(
                  card: _scopeCards[i],
                  index: i,
                  onRemove: () => _removeScopeCard(i),
                  onRemoveArea: (category, area) {
                    setState(() {
                      _scopeCards[i].selectedAreas[category]?.remove(area);
                      if (_scopeCards[i].selectedAreas[category]?.isEmpty ?? false) {
                        _scopeCards[i].selectedAreas.remove(category);
                      }
                    });
                  },
                  // The corrected onAddArea callback
                  onAddArea: (ctx, card) async {
                    await Navigator.push(
                      ctx,
                      MaterialPageRoute(
                        builder: (_) => NetworkPentestAreasPage(
                          scopeCard: card,
                        ),
                      ),
                    );
                    // The card object has already been updated by the child pages.
                    // setState() is now all that's needed to rebuild the widget.
                    setState(() {});
                  },
                ),

              _buildAddScopeButton(),
              const SizedBox(height: 10),
              CheckboxListTile(
                value: _isCrossDomainInsight,
                onChanged: (val) => setState(() => _isCrossDomainInsight = val!),
                title: const Text("Enable Cross-Domain Insight"),
                subtitle: const Text(
                  "Includes analysis across related domains & subdomains for deeper visibility.",
                  style: TextStyle(fontSize: 12, color: Colors.grey),
                ),
                controlAffinity: ListTileControlAffinity.leading, // checkbox on the left
              ),
              CustomInputField(
                  controller: _descriptionTarget,
                  label: "Description",
                  minLines: 5,
                  maxLines: 5),
              const SizedBox(height: 10),
              Row(
                children: [
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      initialValue: _scanMode,
                      items: const [
                        DropdownMenuItem(value: "Scan only", child: Text("Vulnerability Scan only")),
                        DropdownMenuItem(value: "Scan + Attack", child: Text("Vulnerability Scan + Exploitation")),
                      ],
                      onChanged: (val) => setState(() => _scanMode = val!),
                      decoration: InputDecoration(
                        labelText: "Scan Mode",
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(10)),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      initialValue: _reportFormat,
                      items: ["json", "pdf", "md"]
                          .map((f) => DropdownMenuItem(value: f, child: Text(f)))
                          .toList(),
                      onChanged: (val) => setState(() => _reportFormat = val!),
                      decoration: InputDecoration(
                        labelText: "Export Format",
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(10)),
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 10,),
              Center(
                child: ElevatedButton(
                    onPressed: _isScanning ? null : _startScan,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.lightBlue,
                      minimumSize: Size(100, 50)
                    ),
                    child: Text(_isScanning ? "Scanning..." : "Start Scan",style: TextStyle(fontWeight: FontWeight.bold))
                ),
              ),

               if (_scanMessage.isNotEmpty)
                 const SizedBox(height: 10),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey.shade400),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(_scanMessage),
                ),
            ],
          ),
        ),
      ),
    );
  }
}
