// dart: flutter side helpers
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'dart:io';
import 'package:path/path.dart' as path;

final baseUrl = "http://172.17.2.89:8888";

Future<List<Map<String, dynamic>>> uploadFiles(List<File> files) async {
  if (files.isEmpty) return [];

  var uri = Uri.parse("$baseUrl/upload_files");
  var request = http.MultipartRequest("POST", uri);

  for (var f in files) {
    var stream = http.ByteStream(f.openRead());
    var length = await f.length();
    var multipart = http.MultipartFile('files', stream, length, filename: path.basename(f.path));
    request.files.add(multipart);
  }

  var streamed = await request.send();
  var resp = await http.Response.fromStream(streamed);
  if (resp.statusCode < 200 || resp.statusCode >= 300) {
    throw Exception("Upload failed: ${resp.statusCode} ${resp.body}");
  }
  var body = jsonDecode(resp.body);
  // `body['files']` -> [{id, original_filename, path}, ...]
  return List<Map<String, dynamic>>.from(body['files'] ?? []);
}

Future<Map<String, dynamic>> postScanMultipart({
  required String region,
  required String scanType,
  required String scope,
  required List<String> target,
  required String reportFormat,
  required bool crossDomainInsight,
  required String name,
  required String description,
  required Map<String, dynamic> tools,
  List<File>? codebaseFiles,
  List<File>? insiderFiles,
  List<String>? attackSurface,
}) async {
  var uri = Uri.parse("$baseUrl/scan");
  var request = http.MultipartRequest("POST", uri);

// JSON blob for everything except files
  final payload = jsonEncode({
    "region": region,
    "scan_type": scanType,
    "scope": scope,
    "target": target,
    "attack_surface": attackSurface,
    "cross_domain_insight": crossDomainInsight,
    "name": name,
    "description": description,
    "tools": tools,
  });
  request.fields["payload"] = payload;

// Add codebase files
  if (codebaseFiles != null) {
    for (final file in codebaseFiles) {
      final stream = http.ByteStream(file.openRead());
      final length = await file.length();
      request.files.add(http.MultipartFile(
        'codebase_files',
        stream,
        length,
        filename: path.basename(file.path),
      ));
    }
  }

// Add insider files
  if (insiderFiles != null) {
    for (final file in insiderFiles) {
      final stream = http.ByteStream(file.openRead());
      final length = await file.length();
      request.files.add(http.MultipartFile(
        'insider_files',
        stream,
        length,
        filename: path.basename(file.path),
      ));
    }
  }

  // Send
  var streamedResponse = await request.send();
  var response = await http.Response.fromStream(streamedResponse);

  if (response.statusCode < 200 || response.statusCode >= 300) {
    throw Exception("Scan request failed: ${response.statusCode} ${response.body}");
  }

  return jsonDecode(response.body) as Map<String, dynamic>;
}
